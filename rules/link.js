/**
 *  This file is meant to be included as a string template
 */
module.exports = ({ extensionURL = '', username = 'Unknown', clientID = '', clientSecret = '' }) => {

  const template = `function (user, context, callback) {
    /**
     * This rule has been automatically generated by
     * ${username} at ${new Date().toISOString()}
     */
    var request = require('request@2.56.0');
    var queryString = require('querystring');
    var Promise = require('native-or-bluebird@1.2.0');
    var jwt = require('jsonwebtoken@7.1.9');
  
    var CONTINUE_PROTOCOL = 'redirect-callback';
    var LOG_TAG = '[ACCOUNT_LINK]: ';
    console.log(LOG_TAG, 'Entered Account Link Rule');
  
    // 'query' can be undefined when using '/oauth/token' to log in
    context.request.query = context.request.query || {};
    var config = {
      endpoints: {
        linking: '${extensionURL.replace(/\/$/g, '')}',
        userApi: auth0.baseUrl + '/users',
        usersByEmailApi: auth0.baseUrl + '/users-by-email'
      },
      token: {
        clientId: '${clientID}',
        clientSecret: '${clientSecret}',
        issuer: auth0.domain
      }
    };
    
  
    createStrategy().then(callbackWithSuccess).catch(callbackWithFailure);
  
    function createStrategy() {
      console.log(JSON.stringify(user));
      console.log(JSON.stringify(context));
  
      if (shouldLink()) {
        return linkAccounts();
      } else if (shouldPrompt()) {
        return promptUser();
  
      }
  
      return continueAuth();
  
      function shouldLink() {
        return !!context.request.query.link_account_token;
      }
  
      function shouldPrompt() {
        // Trigger this only for connection id of Transmit (This should really be a config paramter than hardcoding)
        // user.identities.length > 1 means that the link is already done and we dont need to do anything

        return !insideRedirect() && !redirectingToContinue() && context.connection === "Transmit" && user.identities.length === 1;
  
        // Check if we're inside a redirect
        // in order to avoid a redirect loop
    
        function insideRedirect() {
          return context.request.query.redirect_uri &&
            context.request.query.redirect_uri.indexOf(config.endpoints.linking) !== -1;
        }
  
  
        // Check if we're coming back from a redirect
        // in order to avoid a redirect loop. User will
        // be sent to /continue at this point. We need
        // to assign them to their primary user if so.
        function redirectingToContinue() {
          return context.protocol === CONTINUE_PROTOCOL;
        }
      }
    }
  
    function verifyToken(token, secret) {
      return new Promise(function(resolve, reject) {
        jwt.verify(token, secret, function(err, decoded) {
          if (err) {
            return reject(err);
          }
  
          return resolve(decoded);
        });
      });
    }
  
    function linkAccounts() {
      var secondAccountToken = context.request.query.link_account_token;
  
   return verifyToken(secondAccountToken, config.token.clientSecret)
        .then(function(decodedToken) {
          // Redirect early if tokens are mismatched
         
          var linkUri = config.endpoints.userApi+'/'+user.user_id+'/identities';
          var headers = {
            Authorization: 'Bearer ' + auth0.accessToken,
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache'
          };
  
          return apiCall({
            method: 'GET',
            url: config.endpoints.userApi+'/'+decodedToken.sub+'?fields=identities',
            headers: headers
          })
            .then(function(secondaryUser) {
              var provider = secondaryUser &&
                secondaryUser.identities &&
                secondaryUser.identities[0] &&
                secondaryUser.identities[0].provider;
  
              return apiCall({
                method: 'POST',
                url: linkUri,
                headers,
                json: { user_id: decodedToken.sub, provider: provider }
              });
            })
            .then(function(_) {
            
              console.info(LOG_TAG, 'Successfully linked accounts for user: ', user.email);
              // The pacth call is just to tag the BindID as a meta attribute on the original account, we probably dont need this
                        return apiCall({
                method: 'PATCH',
                url: config.endpoints.userApi+'/' + user.user_id,
                headers,
                json: { "user_metadata" : { "bindid" :decodedToken.bindid }}
              }).then(function(_) {
                          console.info(LOG_TAG, 'Successfully completed PATCH: ', user.email);
                  return _;
              });
            
              
            });
        });
    }
  
    function continueAuth() {
      return Promise.resolve();
    }
  
    function promptUser() {
      console.log("in prompt user");
      return searchUsersWithBindID().then(function transformUsers(users) {
          console.log(JSON.stringify(users));
          if (users.length === 0) {
            console.log("No matching users found with bindid , trigger linking logic");
            context.redirect = {
              url: buildRedirectUrl(createToken(config.token), context.request.query)
            };
          }
        });
    }
  
    function callbackWithSuccess(_) {
      console.log(JSON.stringify(context));
      callback(null, user, context);
  
      return _;
    }
  
    function callbackWithFailure(err) {
      console.error(LOG_TAG, err.message, err.stack);
  
      callback(err, user, context);
    }
  
    function createToken(tokenInfo) {
      var options = {
        expiresIn: '5m',
        audience: tokenInfo.clientId,
        issuer: qualifyDomain(tokenInfo.issuer)
      };
      // The user_id is of format ConnectionName|sub , for BindID connection sub will be the BindID identifier
      var user_id = user.identities[0].user_id;
      var bindid = user_id.split("|")[1];
  
      var userSub = {
        sub: user.user_id,
        email: user.email,
        bindid: bindid,
        base: auth0.baseUrl
      };
  
      return jwt.sign(userSub, tokenInfo.clientSecret, options);
    }
  
  
     function searchUsersWithBindID() {
      var user_id = user.identities[0].user_id;
      console.log("user_id = " + user_id);
      user_id = user_id.split("|")[1];
  
      console.log("user_id = " + user_id);
      return apiCall({
        url: config.endpoints.userApi,
        search_engine: 'v3',
        qs: {
          q: 'user_metadata.bindid: "' + user_id + '"'
        }
      });
    }
  
  
  
    // Consider moving this logic out of the rule and into the extension
    function buildRedirectUrl(token, q, errorType) {
      var params = {
        child_token: token,
        audience: q.audience,
        client_id: q.client_id,
        redirect_uri: q.redirect_uri,
        scope: q.scope,
        response_type: q.response_type,
        response_mode: q.response_mode,
        auth0Client: q.auth0Client,
        original_state: q.original_state || q.state,
        nonce: q.nonce,
        error_type: errorType
      };
  
      return config.endpoints.linking + '?' + queryString.encode(params);
    }
  
    function qualifyDomain(domain) {
      return 'https://'+domain+'/';
    }
  
    function apiCall(options) {
      return new Promise(function(resolve, reject) {
        var reqOptions = Object.assign({
          url: options.url,
          headers: {
            Authorization: 'Bearer ' + auth0.accessToken,
            Accept: 'application/json'
          },
          json: true
        }, options);
  
        request(reqOptions, function handleResponse(err, response, body) {
          if (err) {
            reject(err);
          } else if (response.statusCode < 200 || response.statusCode >= 300) {
            console.error(LOG_TAG, 'API call failed: ', body);
            reject(new Error(body));
          } else {
            resolve(response.body);
          }
        });
      });
    }
  }
`;

  return template;
};
